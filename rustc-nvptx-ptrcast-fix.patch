From 36134658271867405d4da26d9411170a7f5ddb0b Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Sun, 3 Jul 2022 13:48:14 -0400
Subject: [PATCH 1/7] Can't bitcast pointers in diffrent address spaces Use
 pointercast instead After llvm transitions to opaque pointers, this will not
 always be necessary Keeping asserts for now, but need to be removed

---
 compiler/rustc_codegen_llvm/src/builder.rs   | 24 ++++++++++++++++++--
 compiler/rustc_codegen_llvm/src/intrinsic.rs | 12 +++++-----
 compiler/rustc_codegen_ssa/src/base.rs       |  8 ++++++-
 3 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/compiler/rustc_codegen_llvm/src/builder.rs b/compiler/rustc_codegen_llvm/src/builder.rs
index 2fd6db8cbfe..10f6e9d75f7 100644
--- a/compiler/rustc_codegen_llvm/src/builder.rs
+++ b/compiler/rustc_codegen_llvm/src/builder.rs
@@ -833,6 +833,14 @@ fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {
     }
 
     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {
+        // FIXME: remove before merge
+        assert!(
+            !(matches!(self.cx.type_kind(self.cx.val_ty(val)), TypeKind::Pointer)
+                || matches!(self.cx.type_kind(dest_ty), TypeKind::Pointer)),
+            "val ty is {:?}, dest_ty is {:?}",
+            self.cx.type_kind(self.cx.val_ty(val)),
+            self.cx.type_kind(dest_ty),
+        );
         unsafe { llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, UNNAMED) }
     }
 
@@ -849,6 +857,14 @@ fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &
     }
 
     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {
+        // FIXME: remove before merge
+        assert!(
+            (matches!(self.cx.type_kind(self.cx.val_ty(val)), TypeKind::Pointer)
+                && matches!(self.cx.type_kind(dest_ty), TypeKind::Pointer)),
+            "val ty is {:?}, dest_ty is {:?}",
+            self.cx.type_kind(self.cx.val_ty(val)),
+            self.cx.type_kind(dest_ty),
+        );
         unsafe { llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, UNNAMED) }
     }
 
@@ -1394,7 +1410,7 @@ fn check_store(&mut self, val: &'ll Value, ptr: &'ll Value) -> &'ll Value {
                     Expected {:?}, got {:?}; inserting bitcast",
                 dest_ptr_ty, stored_ptr_ty
             );
-            self.bitcast(ptr, stored_ptr_ty)
+            self.pointercast(ptr, stored_ptr_ty)
         }
     }
 
@@ -1431,7 +1447,11 @@ fn check_call<'b>(
                             Expected {:?} for param {}, got {:?}; injecting bitcast",
                         llfn, expected_ty, i, actual_ty
                     );
-                    self.bitcast(actual_val, expected_ty)
+                    if let TypeKind::Pointer = self.cx.type_kind(expected_ty) {
+                        self.pointercast(actual_val, expected_ty)
+                    } else {
+                        self.bitcast(actual_val, expected_ty)
+                    }
                 } else {
                     actual_val
                 }
diff --git a/compiler/rustc_codegen_llvm/src/intrinsic.rs b/compiler/rustc_codegen_llvm/src/intrinsic.rs
index 00d1796f210..03fa0f19375 100644
--- a/compiler/rustc_codegen_llvm/src/intrinsic.rs
+++ b/compiler/rustc_codegen_llvm/src/intrinsic.rs
@@ -318,15 +318,15 @@ fn codegen_intrinsic_call(
                 } else if use_integer_compare {
                     let integer_ty = self.type_ix(layout.size().bits());
                     let ptr_ty = self.type_ptr_to(integer_ty);
-                    let a_ptr = self.bitcast(a, ptr_ty);
+                    let a_ptr = self.pointercast(a, ptr_ty);
                     let a_val = self.load(integer_ty, a_ptr, layout.align().abi);
-                    let b_ptr = self.bitcast(b, ptr_ty);
+                    let b_ptr = self.pointercast(b, ptr_ty);
                     let b_val = self.load(integer_ty, b_ptr, layout.align().abi);
                     self.icmp(IntPredicate::IntEQ, a_val, b_val)
                 } else {
                     let i8p_ty = self.type_i8p();
-                    let a_ptr = self.bitcast(a, i8p_ty);
-                    let b_ptr = self.bitcast(b, i8p_ty);
+                    let a_ptr = self.pointercast(a, i8p_ty);
+                    let b_ptr = self.pointercast(b, i8p_ty);
                     let n = self.const_usize(layout.size().bytes());
                     let cmp = self.call_intrinsic("memcmp", &[a_ptr, b_ptr, n]);
                     match self.cx.sess().target.arch.as_ref() {
@@ -411,7 +411,7 @@ fn type_test(&mut self, pointer: Self::Value, typeid: Self::Value) -> Self::Valu
         // Test the called operand using llvm.type.test intrinsic. The LowerTypeTests link-time
         // optimization pass replaces calls to this intrinsic with code to test type membership.
         let i8p_ty = self.type_i8p();
-        let bitcast = self.bitcast(pointer, i8p_ty);
+        let bitcast = self.pointercast(pointer, i8p_ty);
         self.call_intrinsic("llvm.type.test", &[bitcast, typeid])
     }
 
@@ -748,7 +748,7 @@ fn codegen_emcc_try<'ll>(
         let catch_data_1 =
             bx.inbounds_gep(catch_data_type, catch_data, &[bx.const_usize(0), bx.const_usize(1)]);
         bx.store(is_rust_panic, catch_data_1, i8_align);
-        let catch_data = bx.bitcast(catch_data, bx.type_i8p());
+        let catch_data = bx.pointercast(catch_data, bx.type_i8p());
 
         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());
         bx.call(catch_ty, None, None, catch_func, &[data, catch_data], None);
diff --git a/compiler/rustc_codegen_ssa/src/base.rs b/compiler/rustc_codegen_ssa/src/base.rs
index ae45ae9d802..639a7913c63 100644
--- a/compiler/rustc_codegen_ssa/src/base.rs
+++ b/compiler/rustc_codegen_ssa/src/base.rs
@@ -254,7 +254,13 @@ pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(
             let lldata_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true);
             let llextra_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true);
             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.
-            (bx.bitcast(lldata, lldata_ty), bx.bitcast(llextra, llextra_ty))
+            let data = bx.pointercast(lldata, lldata_ty);
+            let extra = if let TypeKind::Pointer = bx.type_kind(llextra_ty) {
+                bx.pointercast(llextra, llextra_ty)
+            } else {
+                llextra
+            };
+            (data, extra)
         }
         _ => bug!("unsize_ptr: called on bad types"),
     }
-- 
2.40.1


From d3df384758e09eacd7f5505cda023c823c0b91ff Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Mon, 12 Sep 2022 17:45:02 -0400
Subject: [PATCH 2/7] Fix const ptr casts too

---
 compiler/rustc_codegen_llvm/src/common.rs |  8 ++++----
 compiler/rustc_codegen_llvm/src/consts.rs | 20 ++++++++++++++++++++
 2 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/compiler/rustc_codegen_llvm/src/common.rs b/compiler/rustc_codegen_llvm/src/common.rs
index 9127fba388b..6c8a0918bbc 100644
--- a/compiler/rustc_codegen_llvm/src/common.rs
+++ b/compiler/rustc_codegen_llvm/src/common.rs
@@ -289,7 +289,7 @@ fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: &'ll Type) ->
                 let llval = unsafe {
                     llvm::LLVMRustConstInBoundsGEP2(
                         self.type_i8(),
-                        self.const_bitcast(base_addr, self.type_i8p_ext(base_addr_space)),
+                        self.const_ptrcast(base_addr, self.type_i8p_ext(base_addr_space)),
                         &self.const_usize(offset.bytes()),
                         1,
                     )
@@ -297,7 +297,7 @@ fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: &'ll Type) ->
                 if !matches!(layout.primitive(), Pointer(_)) {
                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }
                 } else {
-                    self.const_bitcast(llval, llty)
+                    self.const_ptrcast(llval, llty)
                 }
             }
         }
@@ -326,12 +326,12 @@ fn from_const_alloc(
             let llval = unsafe {
                 llvm::LLVMRustConstInBoundsGEP2(
                     self.type_i8(),
-                    self.const_bitcast(base_addr, self.type_i8p()),
+                    self.const_ptrcast(base_addr, self.type_i8p()),
                     &self.const_usize(offset.bytes()),
                     1,
                 )
             };
-            self.const_bitcast(llval, llty)
+            self.const_ptrcast(llval, llty)
         };
         PlaceRef::new_sized(llval, layout)
     }
diff --git a/compiler/rustc_codegen_llvm/src/consts.rs b/compiler/rustc_codegen_llvm/src/consts.rs
index 940358acde9..16df061fed4 100644
--- a/compiler/rustc_codegen_llvm/src/consts.rs
+++ b/compiler/rustc_codegen_llvm/src/consts.rs
@@ -185,11 +185,31 @@ fn check_and_apply_linkage<'ll, 'tcx>(
 }
 
 pub fn ptrcast<'ll>(val: &'ll Value, ty: &'ll Type) -> &'ll Value {
+    // FIXME: remove before merge
+    let val_ty_kind = unsafe { llvm::LLVMRustGetTypeKind(common::val_ty(val)).to_generic() };
+    let dest_ty_kind = unsafe { llvm::LLVMRustGetTypeKind(ty).to_generic() };
+    assert!(
+        (matches!(val_ty_kind, rustc_codegen_ssa::common::TypeKind::Pointer)
+            && matches!(dest_ty_kind, rustc_codegen_ssa::common::TypeKind::Pointer)),
+        "val ty is {:?}, dest_ty is {:?}",
+        val_ty_kind,
+        dest_ty_kind,
+    );
     unsafe { llvm::LLVMConstPointerCast(val, ty) }
 }
 
 impl<'ll> CodegenCx<'ll, '_> {
     pub(crate) fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {
+        // FIXME: remove before merge
+        assert!(
+            !(matches!(
+                self.type_kind(self.val_ty(val)),
+                rustc_codegen_ssa::common::TypeKind::Pointer
+            ) || matches!(self.type_kind(ty), rustc_codegen_ssa::common::TypeKind::Pointer)),
+            "val ty is {:?}, dest_ty is {:?}",
+            self.type_kind(self.val_ty(val)),
+            self.type_kind(ty),
+        );
         unsafe { llvm::LLVMConstBitCast(val, ty) }
     }
 
-- 
2.40.1


From 612be4673dd0bbc6473f9ef4573ad69bae57ec4b Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Mon, 9 Jan 2023 20:51:01 -0500
Subject: [PATCH 3/7] Add new experimental #[address_space] built-in

Only the skeleton for now, no codegen yet
---
 .../rustc_codegen_ssa/src/codegen_attrs.rs    | 43 +++++++++++++++++++
 compiler/rustc_feature/src/active.rs          |  2 +
 compiler/rustc_feature/src/builtin_attrs.rs   |  1 +
 .../src/middle/codegen_fn_attrs.rs            |  4 ++
 compiler/rustc_span/src/symbol.rs             |  1 +
 .../feature-gate-address_space.rs             | 13 ++++++
 .../feature-gate-address_space.stderr         | 38 ++++++++++++++++
 7 files changed, 102 insertions(+)
 create mode 100644 tests/ui/feature-gates/feature-gate-address_space.rs
 create mode 100644 tests/ui/feature-gates/feature-gate-address_space.stderr

diff --git a/compiler/rustc_codegen_ssa/src/codegen_attrs.rs b/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
index 8dae5dab429..2eeb74fb36f 100644
--- a/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
+++ b/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
@@ -314,6 +314,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {
                     codegen_fn_attrs.link_ordinal = ordinal;
                 }
             }
+            sym::address_space => {
+                if let address_space @ Some(_) = check_address_space(tcx, attr) {
+                    codegen_fn_attrs.address_space = address_space;
+                }
+            }
             sym::no_sanitize => {
                 no_sanitize_span = Some(attr.span);
                 if let Some(list) = attr.meta_item_list() {
@@ -649,6 +654,44 @@ fn check_link_name_xor_ordinal(
     }
 }
 
+fn check_address_space(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {
+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};
+    let meta_item_list = attr.meta_item_list();
+    let meta_item_list = meta_item_list.as_deref();
+    let sole_meta_list = match meta_item_list {
+        Some([item]) => item.lit(),
+        Some(_) => {
+            tcx.sess
+                .struct_span_err(attr.span, "incorrect number of arguments to `#[address_space]`")
+                .note("the attribute requires exactly one argument")
+                .emit();
+            return None;
+        }
+        _ => None,
+    };
+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =
+        sole_meta_list
+    {
+        if *ordinal <= u16::MAX as u128 {
+            Some(*ordinal as u16)
+        } else {
+            let msg =
+                format!("address space value in `address_space` is too large: `{}`", &ordinal);
+            tcx.sess
+                .struct_span_err(attr.span, &msg)
+                .note("the value may not exceed `u16::MAX`")
+                .emit();
+            None
+        }
+    } else {
+        tcx.sess
+            .struct_span_err(attr.span, "illegal address space format in `address_space`")
+            .note("an unsuffixed integer value, e.g., `1`, is expected")
+            .emit();
+        None
+    }
+}
+
 pub fn provide(providers: &mut Providers) {
     *providers = Providers { codegen_fn_attrs, should_inherit_track_caller, ..*providers };
 }
diff --git a/compiler/rustc_feature/src/active.rs b/compiler/rustc_feature/src/active.rs
index 27d30c315af..9875a488d44 100644
--- a/compiler/rustc_feature/src/active.rs
+++ b/compiler/rustc_feature/src/active.rs
@@ -291,6 +291,8 @@ pub fn set(&self, features: &mut Features, span: Span) {
     (active, abi_ptx, "1.15.0", Some(38788), None),
     /// Allows `extern "x86-interrupt" fn()`.
     (active, abi_x86_interrupt, "1.17.0", Some(40180), None),
+    /// Allows `#[address_space = "..."]` on static varibles.
+    (incomplete, address_space, "CURRENT_RUSTC_VERSION", Some(1), None),
     /// Allows additional const parameter types, such as `&'static str` or user defined types
     (incomplete, adt_const_params, "1.56.0", Some(95174), None),
     /// Allows defining an `#[alloc_error_handler]`.
diff --git a/compiler/rustc_feature/src/builtin_attrs.rs b/compiler/rustc_feature/src/builtin_attrs.rs
index fe05d4590e7..4477e0b367a 100644
--- a/compiler/rustc_feature/src/builtin_attrs.rs
+++ b/compiler/rustc_feature/src/builtin_attrs.rs
@@ -398,6 +398,7 @@ pub struct BuiltinAttribute {
         experimental!(no_sanitize)
     ),
     gated!(no_coverage, Normal, template!(Word), WarnFollowing, experimental!(no_coverage)),
+    gated!(address_space, Normal, template!(List: "space"), ErrorPreceding, experimental!(address_space)),
 
     ungated!(
         doc, Normal, template!(List: "hidden|inline|...", NameValueStr: "string"), DuplicatesOk
diff --git a/compiler/rustc_middle/src/middle/codegen_fn_attrs.rs b/compiler/rustc_middle/src/middle/codegen_fn_attrs.rs
index c4601a1fb41..da8b6420276 100644
--- a/compiler/rustc_middle/src/middle/codegen_fn_attrs.rs
+++ b/compiler/rustc_middle/src/middle/codegen_fn_attrs.rs
@@ -43,6 +43,9 @@ pub struct CodegenFnAttrs {
     /// The `#[repr(align(...))]` attribute. Indicates the value of which the function should be
     /// aligned to.
     pub alignment: Option<u32>,
+    /// The `#[address_space = "..."]` attribute, indicating in which address space a
+    /// Rust-defined/foreign static value resides.
+    pub address_space: Option<u16>,
 }
 
 bitflags! {
@@ -121,6 +124,7 @@ pub const fn new() -> CodegenFnAttrs {
             no_sanitize: SanitizerSet::empty(),
             instruction_set: None,
             alignment: None,
+            address_space: None,
         }
     }
 
diff --git a/compiler/rustc_span/src/symbol.rs b/compiler/rustc_span/src/symbol.rs
index b97ec6c684b..0f977a853c3 100644
--- a/compiler/rustc_span/src/symbol.rs
+++ b/compiler/rustc_span/src/symbol.rs
@@ -334,6 +334,7 @@
         add_assign,
         add_with_overflow,
         address,
+        address_space,
         adt_const_params,
         advanced_slice_patterns,
         adx_target_feature,
diff --git a/tests/ui/feature-gates/feature-gate-address_space.rs b/tests/ui/feature-gates/feature-gate-address_space.rs
new file mode 100644
index 00000000000..886c5b564a6
--- /dev/null
+++ b/tests/ui/feature-gates/feature-gate-address_space.rs
@@ -0,0 +1,13 @@
+#[address_space(0)] //~ ERROR the `#[address_space]` attribute is an experimental feature
+static FOO: usize = 42;
+
+extern "C" {
+    #[address_space(0)] //~ ERROR the `#[address_space]` attribute is an experimental feature
+    static EXTERN_FOO: usize;
+}
+
+#[address_space(65_536)] //~ ERROR the `#[address_space]` attribute is an experimental feature
+                         //~^ ERROR address space value in `address_space` is too large: `65536`
+static TOO_BIG: usize = 7;
+
+fn main() {}
diff --git a/tests/ui/feature-gates/feature-gate-address_space.stderr b/tests/ui/feature-gates/feature-gate-address_space.stderr
new file mode 100644
index 00000000000..91eedd877ff
--- /dev/null
+++ b/tests/ui/feature-gates/feature-gate-address_space.stderr
@@ -0,0 +1,38 @@
+error[E0658]: the `#[address_space]` attribute is an experimental feature
+  --> $DIR/feature-gate-address_space.rs:1:1
+   |
+LL | #[address_space(0)]
+   | ^^^^^^^^^^^^^^^^^^^
+   |
+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information
+   = help: add `#![feature(address_space)]` to the crate attributes to enable
+
+error[E0658]: the `#[address_space]` attribute is an experimental feature
+  --> $DIR/feature-gate-address_space.rs:5:5
+   |
+LL |     #[address_space(0)]
+   |     ^^^^^^^^^^^^^^^^^^^
+   |
+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information
+   = help: add `#![feature(address_space)]` to the crate attributes to enable
+
+error[E0658]: the `#[address_space]` attribute is an experimental feature
+  --> $DIR/feature-gate-address_space.rs:9:1
+   |
+LL | #[address_space(65_536)]
+   | ^^^^^^^^^^^^^^^^^^^^^^^^
+   |
+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information
+   = help: add `#![feature(address_space)]` to the crate attributes to enable
+
+error: address space value in `address_space` is too large: `65536`
+  --> $DIR/feature-gate-address_space.rs:9:1
+   |
+LL | #[address_space(65_536)]
+   | ^^^^^^^^^^^^^^^^^^^^^^^^
+   |
+   = note: the value may not exceed `u16::MAX`
+
+error: aborting due to 4 previous errors
+
+For more information about this error, try `rustc --explain E0658`.
-- 
2.40.1


From 5fc194e63504772afd07f9b2b8fc69ff50e7d598 Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Mon, 9 Jan 2023 21:01:37 -0500
Subject: [PATCH 4/7] Initial codegen for #[address_space], without tests yet

---
 compiler/rustc_codegen_llvm/src/allocator.rs  |  9 +++-
 compiler/rustc_codegen_llvm/src/common.rs     |  2 +-
 compiler/rustc_codegen_llvm/src/consts.rs     | 21 ++++++----
 compiler/rustc_codegen_llvm/src/context.rs    |  2 +-
 .../src/coverageinfo/mod.rs                   |  5 ++-
 .../rustc_codegen_llvm/src/debuginfo/gdb.rs   |  2 +-
 compiler/rustc_codegen_llvm/src/declare.rs    | 38 ++++++++++++++---
 compiler/rustc_codegen_llvm/src/intrinsic.rs  |  4 +-
 compiler/rustc_codegen_llvm/src/llvm/ffi.rs   | 15 ++++++-
 compiler/rustc_codegen_llvm/src/llvm/mod.rs   | 15 ++++++-
 compiler/rustc_codegen_llvm/src/mono_item.rs  |  2 +-
 .../rustc_llvm/llvm-wrapper/RustWrapper.cpp   | 41 ++++++++++++++++---
 12 files changed, 124 insertions(+), 32 deletions(-)

diff --git a/compiler/rustc_codegen_llvm/src/allocator.rs b/compiler/rustc_codegen_llvm/src/allocator.rs
index 668d9292705..ea82d45bf24 100644
--- a/compiler/rustc_codegen_llvm/src/allocator.rs
+++ b/compiler/rustc_codegen_llvm/src/allocator.rs
@@ -148,7 +148,14 @@ pub(crate) unsafe fn codegen(
 
     // __rust_alloc_error_handler_should_panic
     let name = OomStrategy::SYMBOL;
-    let ll_g = llvm::LLVMRustGetOrInsertGlobal(llmod, name.as_ptr().cast(), name.len(), i8);
+    let ll_g = llvm::LLVMRustGetOrInsertGlobal(
+        llmod,
+        name.as_ptr().cast(),
+        name.len(),
+        i8,
+        false,
+        0 as c_uint,
+    );
     if tcx.sess.target.default_hidden_visibility {
         llvm::LLVMRustSetVisibility(ll_g, llvm::Visibility::Hidden);
     }
diff --git a/compiler/rustc_codegen_llvm/src/common.rs b/compiler/rustc_codegen_llvm/src/common.rs
index 6c8a0918bbc..ba1599deb9f 100644
--- a/compiler/rustc_codegen_llvm/src/common.rs
+++ b/compiler/rustc_codegen_llvm/src/common.rs
@@ -196,7 +196,7 @@ fn const_str(&self, s: &str) -> (&'ll Value, &'ll Value) {
             .or_insert_with(|| {
                 let sc = self.const_bytes(s.as_bytes());
                 let sym = self.generate_local_symbol_name("str");
-                let g = self.define_global(&sym, self.val_ty(sc)).unwrap_or_else(|| {
+                let g = self.define_global(&sym, self.val_ty(sc), None).unwrap_or_else(|| {
                     bug!("symbol `{}` is already defined", sym);
                 });
                 unsafe {
diff --git a/compiler/rustc_codegen_llvm/src/consts.rs b/compiler/rustc_codegen_llvm/src/consts.rs
index 16df061fed4..5ec22a1c8d7 100644
--- a/compiler/rustc_codegen_llvm/src/consts.rs
+++ b/compiler/rustc_codegen_llvm/src/consts.rs
@@ -152,7 +152,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(
 
         unsafe {
             // Declare a symbol `foo` with the desired linkage.
-            let g1 = cx.declare_global(sym, cx.type_i8());
+            let g1 = cx.declare_global(sym, cx.type_i8(), attrs.address_space);
             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));
 
             // Declare an internal global `extern_with_linkage_foo` which
@@ -163,7 +163,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(
             // zero.
             let mut real_name = "_rust_extern_with_linkage_".to_string();
             real_name.push_str(sym);
-            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {
+            let g2 = cx.define_global(&real_name, llty, attrs.address_space).unwrap_or_else(|| {
                 cx.sess().emit_fatal(SymbolAlreadyDefined {
                     span: cx.tcx.def_span(def_id),
                     symbol_name: sym,
@@ -176,11 +176,11 @@ fn check_and_apply_linkage<'ll, 'tcx>(
     } else if cx.tcx.sess.target.arch == "x86" &&
         let Some(dllimport) = common::get_dllimport(cx.tcx, def_id, sym)
     {
-        cx.declare_global(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&cx.tcx.sess.target), true), llty)
+        cx.declare_global(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&cx.tcx.sess.target), true), llty, attrs.address_space)
     } else {
         // Generate an external declaration.
         // FIXME(nagisa): investigate whether it can be changed into define_global
-        cx.declare_global(sym, llty)
+        cx.declare_global(sym, llty, attrs.address_space)
     }
 }
 
@@ -223,13 +223,14 @@ pub(crate) fn static_addr_of_mut(
             let gv = match kind {
                 Some(kind) if !self.tcx.sess.fewer_names() => {
                     let name = self.generate_local_symbol_name(kind);
-                    let gv = self.define_global(&name, self.val_ty(cv)).unwrap_or_else(|| {
-                        bug!("symbol `{}` is already defined", name);
-                    });
+                    let gv =
+                        self.define_global(&name, self.val_ty(cv), None).unwrap_or_else(|| {
+                            bug!("symbol `{}` is already defined", name);
+                        });
                     llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);
                     gv
                 }
-                _ => self.define_private_global(self.val_ty(cv)),
+                _ => self.define_private_global(self.val_ty(cv), None),
             };
             llvm::LLVMSetInitializer(gv, cv);
             set_global_alignment(self, gv, align);
@@ -267,7 +268,7 @@ pub(crate) fn get_static(&self, def_id: DefId) -> &'ll Value {
                 }
             }
 
-            let g = self.declare_global(sym, llty);
+            let g = self.declare_global(sym, llty, fn_attrs.address_space);
 
             if !self.tcx.is_reachable_non_generic(def_id) {
                 unsafe {
@@ -412,6 +413,8 @@ fn codegen_static(&self, def_id: DefId, is_mutable: bool) {
                     name.as_ptr().cast(),
                     name.len(),
                     val_llty,
+                    attrs.address_space.is_some(),
+                    attrs.address_space.unwrap_or_default() as c_uint,
                 );
 
                 llvm::LLVMRustSetLinkage(new_g, linkage);
diff --git a/compiler/rustc_codegen_llvm/src/context.rs b/compiler/rustc_codegen_llvm/src/context.rs
index 83101a85435..90fc22b25da 100644
--- a/compiler/rustc_codegen_llvm/src/context.rs
+++ b/compiler/rustc_codegen_llvm/src/context.rs
@@ -911,7 +911,7 @@ pub(crate) fn eh_catch_typeinfo(&self) -> &'ll Value {
             _ => {
                 let ty = self
                     .type_struct(&[self.type_ptr_to(self.type_isize()), self.type_i8p()], false);
-                self.declare_global("rust_eh_catch_typeinfo", ty)
+                self.declare_global("rust_eh_catch_typeinfo", ty, None)
             }
         };
         let eh_catch_typeinfo = self.const_bitcast(eh_catch_typeinfo, self.type_i8p());
diff --git a/compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs b/compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs
index 3dc0ac03312..3c9cb312ab1 100644
--- a/compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs
+++ b/compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs
@@ -337,7 +337,7 @@ pub(crate) fn save_cov_data_to_mod<'ll, 'tcx>(
     .expect("Rust Coverage section name failed UTF-8 conversion");
     debug!("covmap section name: {:?}", covmap_section_name);
 
-    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);
+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name, None);
     llvm::set_initializer(llglobal, cov_data_val);
     llvm::set_global_constant(llglobal, true);
     llvm::set_linkage(llglobal, llvm::Linkage::PrivateLinkage);
@@ -370,7 +370,8 @@ pub(crate) fn save_func_record_to_mod<'ll, 'tcx>(
     .expect("Rust Coverage function record section name failed UTF-8 conversion");
     debug!("function record section name: {:?}", func_record_section_name);
 
-    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(func_record_val), &func_record_var_name);
+    let llglobal =
+        llvm::add_global(cx.llmod, cx.val_ty(func_record_val), &func_record_var_name, None);
     llvm::set_initializer(llglobal, func_record_val);
     llvm::set_global_constant(llglobal, true);
     llvm::set_linkage(llglobal, llvm::Linkage::LinkOnceODRLinkage);
diff --git a/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs b/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
index aaf5dbd9930..7ce19079383 100644
--- a/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
+++ b/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
@@ -70,7 +70,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '
             let llvm_type = cx.type_array(cx.type_i8(), section_contents.len() as u64);
 
             let section_var = cx
-                .define_global(section_var_name, llvm_type)
+                .define_global(section_var_name, llvm_type, None)
                 .unwrap_or_else(|| bug!("symbol `{}` is already defined", section_var_name));
             llvm::LLVMSetSection(section_var, section_name.as_ptr().cast());
             llvm::LLVMSetInitializer(section_var, cx.const_bytes(section_contents));
diff --git a/compiler/rustc_codegen_llvm/src/declare.rs b/compiler/rustc_codegen_llvm/src/declare.rs
index cc2a5d158be..849f7162264 100644
--- a/compiler/rustc_codegen_llvm/src/declare.rs
+++ b/compiler/rustc_codegen_llvm/src/declare.rs
@@ -62,9 +62,23 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {
     ///
     /// If there’s a value with the same name already declared, the function will
     /// return its Value instead.
-    pub fn declare_global(&self, name: &str, ty: &'ll Type) -> &'ll Value {
+    pub fn declare_global(
+        &self,
+        name: &str,
+        ty: &'ll Type,
+        address_space: Option<u16>,
+    ) -> &'ll Value {
         debug!("declare_global(name={:?})", name);
-        unsafe { llvm::LLVMRustGetOrInsertGlobal(self.llmod, name.as_ptr().cast(), name.len(), ty) }
+        unsafe {
+            llvm::LLVMRustGetOrInsertGlobal(
+                self.llmod,
+                name.as_ptr().cast(),
+                name.len(),
+                ty,
+                address_space.is_some(),
+                address_space.unwrap_or_default() as _,
+            )
+        }
     }
 
     /// Declare a C ABI function.
@@ -169,19 +183,31 @@ pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Val
     /// return `None` if the name already has a definition associated with it. In that
     /// case an error should be reported to the user, because it usually happens due
     /// to user’s fault (e.g., misuse of `#[no_mangle]` or `#[export_name]` attributes).
-    pub fn define_global(&self, name: &str, ty: &'ll Type) -> Option<&'ll Value> {
+    pub fn define_global(
+        &self,
+        name: &str,
+        ty: &'ll Type,
+        address_space: Option<u16>,
+    ) -> Option<&'ll Value> {
         if self.get_defined_value(name).is_some() {
             None
         } else {
-            Some(self.declare_global(name, ty))
+            Some(self.declare_global(name, ty, address_space))
         }
     }
 
     /// Declare a private global
     ///
     /// Use this function when you intend to define a global without a name.
-    pub fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {
-        unsafe { llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty) }
+    pub fn define_private_global(&self, ty: &'ll Type, address_space: Option<u16>) -> &'ll Value {
+        unsafe {
+            llvm::LLVMRustInsertPrivateGlobal(
+                self.llmod,
+                ty,
+                address_space.is_some(),
+                address_space.unwrap_or_default() as _,
+            )
+        }
     }
 
     /// Gets declared value by name.
diff --git a/compiler/rustc_codegen_llvm/src/intrinsic.rs b/compiler/rustc_codegen_llvm/src/intrinsic.rs
index 03fa0f19375..c2b1350907c 100644
--- a/compiler/rustc_codegen_llvm/src/intrinsic.rs
+++ b/compiler/rustc_codegen_llvm/src/intrinsic.rs
@@ -566,11 +566,11 @@ fn codegen_msvc_try<'ll>(
         //
         // When modifying, make sure that the type_name string exactly matches
         // the one used in library/panic_unwind/src/seh.rs.
-        let type_info_vtable = bx.declare_global("??_7type_info@@6B@", bx.type_i8p());
+        let type_info_vtable = bx.declare_global("??_7type_info@@6B@", bx.type_i8p(), None);
         let type_name = bx.const_bytes(b"rust_panic\0");
         let type_info =
             bx.const_struct(&[type_info_vtable, bx.const_null(bx.type_i8p()), type_name], false);
-        let tydesc = bx.declare_global("__rust_panic_type_info", bx.val_ty(type_info));
+        let tydesc = bx.declare_global("__rust_panic_type_info", bx.val_ty(type_info), None);
         unsafe {
             llvm::LLVMRustSetLinkage(tydesc, llvm::Linkage::LinkOnceODRLinkage);
             llvm::SetUniqueComdat(bx.llmod, tydesc);
diff --git a/compiler/rustc_codegen_llvm/src/llvm/ffi.rs b/compiler/rustc_codegen_llvm/src/llvm/ffi.rs
index 61365e6dc4b..d7e4a1a9895 100644
--- a/compiler/rustc_codegen_llvm/src/llvm/ffi.rs
+++ b/compiler/rustc_codegen_llvm/src/llvm/ffi.rs
@@ -1167,14 +1167,27 @@ pub fn LLVMRustConstInBoundsGEP2<'a>(
     // Operations on global variables
     pub fn LLVMIsAGlobalVariable(GlobalVar: &Value) -> Option<&Value>;
     pub fn LLVMAddGlobal<'a>(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;
+    pub fn LLVMAddGlobalInAddressSpace<'a>(
+        M: &'a Module,
+        Ty: &'a Type,
+        Name: *const c_char,
+        AddressSpace: c_uint,
+    ) -> &'a Value;
     pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> Option<&Value>;
     pub fn LLVMRustGetOrInsertGlobal<'a>(
         M: &'a Module,
         Name: *const c_char,
         NameLen: size_t,
         T: &'a Type,
+        InAddressSpace: bool,
+        AddressSpace: c_uint,
+    ) -> &'a Value;
+    pub fn LLVMRustInsertPrivateGlobal<'a>(
+        M: &'a Module,
+        T: &'a Type,
+        InAddressSpace: bool,
+        AddressSpace: c_uint,
     ) -> &'a Value;
-    pub fn LLVMRustInsertPrivateGlobal<'a>(M: &'a Module, T: &'a Type) -> &'a Value;
     pub fn LLVMGetFirstGlobal(M: &Module) -> Option<&Value>;
     pub fn LLVMGetNextGlobal(GlobalVar: &Value) -> Option<&Value>;
     pub fn LLVMDeleteGlobal(GlobalVar: &Value);
diff --git a/compiler/rustc_codegen_llvm/src/llvm/mod.rs b/compiler/rustc_codegen_llvm/src/llvm/mod.rs
index 4f5cc575da6..c32f13aa10b 100644
--- a/compiler/rustc_codegen_llvm/src/llvm/mod.rs
+++ b/compiler/rustc_codegen_llvm/src/llvm/mod.rs
@@ -200,9 +200,20 @@ pub fn set_section(llglobal: &Value, section_name: &str) {
     }
 }
 
-pub fn add_global<'a>(llmod: &'a Module, ty: &'a Type, name: &str) -> &'a Value {
+pub fn add_global<'a>(
+    llmod: &'a Module,
+    ty: &'a Type,
+    name: &str,
+    address_space: Option<u16>,
+) -> &'a Value {
     let name_cstr = CString::new(name).expect("unexpected CString error");
-    unsafe { LLVMAddGlobal(llmod, ty, name_cstr.as_ptr()) }
+    if let Some(address_space) = address_space {
+        unsafe {
+            LLVMAddGlobalInAddressSpace(llmod, ty, name_cstr.as_ptr(), address_space as c_uint)
+        }
+    } else {
+        unsafe { LLVMAddGlobal(llmod, ty, name_cstr.as_ptr()) }
+    }
 }
 
 pub fn set_initializer(llglobal: &Value, constant_val: &Value) {
diff --git a/compiler/rustc_codegen_llvm/src/mono_item.rs b/compiler/rustc_codegen_llvm/src/mono_item.rs
index 59bdc60830f..e1f4ac70878 100644
--- a/compiler/rustc_codegen_llvm/src/mono_item.rs
+++ b/compiler/rustc_codegen_llvm/src/mono_item.rs
@@ -25,7 +25,7 @@ fn predefine_static(
         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());
         let llty = self.layout_of(ty).llvm_type(self);
 
-        let g = self.define_global(symbol_name, llty).unwrap_or_else(|| {
+        let g = self.define_global(symbol_name, llty, None).unwrap_or_else(|| {
             self.sess()
                 .emit_fatal(SymbolAlreadyDefined { span: self.tcx.def_span(def_id), symbol_name })
         });
diff --git a/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp b/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
index 49acd71b3e1..6b09a6f525a 100644
--- a/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
+++ b/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
@@ -127,8 +127,27 @@ extern "C" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,
   );
 }
 
+
+#if LLVM_VERSION_LT(16, 0)
+static Optional<unsigned> wrap_opt_address_space(bool InAddressSpace, unsigned AddressSpace) {
+#else
+static std::optional<unsigned> wrap_opt_address_space(bool InAddressSpace, unsigned AddressSpace) {
+#endif
+  if (InAddressSpace) {
+    return AddressSpace;
+  } else {
+#if LLVM_VERSION_LT(16, 0)
+    return None;
+#else
+    return std::nullopt;
+#endif
+  }
+}
+
+
 extern "C" LLVMValueRef
-LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty) {
+LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty,
+                          bool InAddressSpace, unsigned AddressSpace) {
   Module *Mod = unwrap(M);
   StringRef NameRef(Name, NameLen);
 
@@ -138,18 +157,30 @@ LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, size_t NameLen, LLV
   // GlobalVariable* so we can access linkage, visibility, etc.
   GlobalVariable *GV = Mod->getGlobalVariable(NameRef, true);
   if (!GV)
-    GV = new GlobalVariable(*Mod, unwrap(Ty), false,
-                            GlobalValue::ExternalLinkage, nullptr, NameRef);
+    GV = new GlobalVariable(*Mod,
+                            unwrap(Ty),
+                            false,
+                            GlobalValue::ExternalLinkage,
+                            nullptr,
+                            NameRef,
+                            nullptr,
+                            GlobalValue::NotThreadLocal,
+                            wrap_opt_address_space(InAddressSpace, AddressSpace));
   return wrap(GV);
 }
 
 extern "C" LLVMValueRef
-LLVMRustInsertPrivateGlobal(LLVMModuleRef M, LLVMTypeRef Ty) {
+LLVMRustInsertPrivateGlobal(LLVMModuleRef M, LLVMTypeRef Ty,
+                            bool InAddressSpace, unsigned AddressSpace) {
   return wrap(new GlobalVariable(*unwrap(M),
                                  unwrap(Ty),
                                  false,
                                  GlobalValue::PrivateLinkage,
-                                 nullptr));
+                                 nullptr,
+                                 "",
+                                 nullptr,
+                                 GlobalValue::NotThreadLocal,
+                                 wrap_opt_address_space(InAddressSpace, AddressSpace)));
 }
 
 static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {
-- 
2.40.1


From 4e96e533f8c481e0950f340d0382bed676d6fe60 Mon Sep 17 00:00:00 2001
From: Julia Tatz <julia.tatz@childrens.harvard.edu>
Date: Wed, 25 Jan 2023 20:05:28 -0500
Subject: [PATCH 5/7] Fix eh_catch_typeinfo, debug_gdb_scripts, & va-arg
 bitcasts -> pointercasts

---
 compiler/rustc_codegen_llvm/src/context.rs       |  2 +-
 compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs |  2 +-
 compiler/rustc_codegen_llvm/src/va_arg.rs        | 12 ++++++------
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/compiler/rustc_codegen_llvm/src/context.rs b/compiler/rustc_codegen_llvm/src/context.rs
index 90fc22b25da..83b8920b0c6 100644
--- a/compiler/rustc_codegen_llvm/src/context.rs
+++ b/compiler/rustc_codegen_llvm/src/context.rs
@@ -914,7 +914,7 @@ pub(crate) fn eh_catch_typeinfo(&self) -> &'ll Value {
                 self.declare_global("rust_eh_catch_typeinfo", ty, None)
             }
         };
-        let eh_catch_typeinfo = self.const_bitcast(eh_catch_typeinfo, self.type_i8p());
+        let eh_catch_typeinfo = self.const_ptrcast(eh_catch_typeinfo, self.type_i8p());
         self.eh_catch_typeinfo.set(Some(eh_catch_typeinfo));
         eh_catch_typeinfo
     }
diff --git a/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs b/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
index 7ce19079383..615a8ff07b7 100644
--- a/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
+++ b/compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs
@@ -19,7 +19,7 @@
 pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_, '_, '_>) {
     if needs_gdb_debug_scripts_section(bx) {
         let gdb_debug_scripts_section =
-            bx.const_bitcast(get_or_insert_gdb_debug_scripts_section_global(bx), bx.type_i8p());
+            bx.const_ptrcast(get_or_insert_gdb_debug_scripts_section_global(bx), bx.type_i8p());
         // Load just the first byte as that's all that's necessary to force
         // LLVM to keep around the reference to the global.
         let volatile_load_instruction = bx.volatile_load(bx.type_i8(), gdb_debug_scripts_section);
diff --git a/compiler/rustc_codegen_llvm/src/va_arg.rs b/compiler/rustc_codegen_llvm/src/va_arg.rs
index b19398e68c2..f261b0b5193 100644
--- a/compiler/rustc_codegen_llvm/src/va_arg.rs
+++ b/compiler/rustc_codegen_llvm/src/va_arg.rs
@@ -35,7 +35,7 @@ fn emit_direct_ptr_va_arg<'ll, 'tcx>(
     let va_list_ty = bx.type_i8p();
     let va_list_ptr_ty = bx.type_ptr_to(va_list_ty);
     let va_list_addr = if list.layout.llvm_type(bx.cx) != va_list_ptr_ty {
-        bx.bitcast(list.immediate(), va_list_ptr_ty)
+        bx.pointercast(list.immediate(), va_list_ptr_ty)
     } else {
         list.immediate()
     };
@@ -56,9 +56,9 @@ fn emit_direct_ptr_va_arg<'ll, 'tcx>(
     if size.bytes() < slot_size.bytes() && bx.tcx().sess.target.endian == Endian::Big {
         let adjusted_size = bx.cx().const_i32((slot_size.bytes() - size.bytes()) as i32);
         let adjusted = bx.inbounds_gep(bx.type_i8(), addr, &[adjusted_size]);
-        (bx.bitcast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)
+        (bx.pointercast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)
     } else {
-        (bx.bitcast(addr, bx.cx().type_ptr_to(llty)), addr_align)
+        (bx.pointercast(addr, bx.cx().type_ptr_to(llty)), addr_align)
     }
 }
 
@@ -158,7 +158,7 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(
         reg_addr = bx.gep(bx.type_i8(), reg_addr, &[offset]);
     }
     let reg_type = layout.llvm_type(bx);
-    let reg_addr = bx.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));
+    let reg_addr = bx.pointercast(reg_addr, bx.cx.type_ptr_to(reg_type));
     let reg_value = bx.load(reg_type, reg_addr, layout.align.abi);
     bx.br(end);
 
@@ -250,10 +250,10 @@ fn emit_s390x_va_arg<'ll, 'tcx>(
     let val_type = layout.llvm_type(bx);
     let val_addr = if indirect {
         let ptr_type = bx.cx.type_ptr_to(val_type);
-        let ptr_addr = bx.bitcast(val_addr, bx.cx.type_ptr_to(ptr_type));
+        let ptr_addr = bx.pointercast(val_addr, bx.cx.type_ptr_to(ptr_type));
         bx.load(ptr_type, ptr_addr, bx.tcx().data_layout.pointer_align.abi)
     } else {
-        bx.bitcast(val_addr, bx.cx.type_ptr_to(val_type))
+        bx.pointercast(val_addr, bx.cx.type_ptr_to(val_type))
     };
     bx.load(val_type, val_addr, layout.align.abi)
 }
-- 
2.40.1


From 5b4cb4764e528be496f59eccb483eec2d061a6a0 Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Sun, 3 Jul 2022 22:32:56 -0400
Subject: [PATCH 6/7] nvptx fixes

---
 compiler/rustc_target/src/abi/call/nvptx64.rs | 59 ++-----------------
 .../src/spec/nvptx64_nvidia_cuda.rs           |  6 +-
 tests/assembly/asm/nvptx-types.rs             | 12 ++--
 3 files changed, 16 insertions(+), 61 deletions(-)

diff --git a/compiler/rustc_target/src/abi/call/nvptx64.rs b/compiler/rustc_target/src/abi/call/nvptx64.rs
index 4abe51cd697..3982a41752f 100644
--- a/compiler/rustc_target/src/abi/call/nvptx64.rs
+++ b/compiler/rustc_target/src/abi/call/nvptx64.rs
@@ -1,52 +1,12 @@
-use crate::abi::call::{ArgAbi, FnAbi, PassMode, Reg, Size, Uniform};
-use crate::abi::{HasDataLayout, TyAbiInterface};
-
-fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {
-    if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {
-        ret.make_indirect();
-    }
-}
+// Reference: PTX Writer's Guide to Interoperability
+// https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability
 
-fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {
-    if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {
-        arg.make_indirect();
-    }
-}
-
-fn classify_arg_kernel<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)
-where
-    Ty: TyAbiInterface<'a, C> + Copy,
-    C: HasDataLayout,
-{
-    if matches!(arg.mode, PassMode::Pair(..)) && (arg.layout.is_adt() || arg.layout.is_tuple()) {
-        let align_bytes = arg.layout.align.abi.bytes();
-
-        let unit = match align_bytes {
-            1 => Reg::i8(),
-            2 => Reg::i16(),
-            4 => Reg::i32(),
-            8 => Reg::i64(),
-            16 => Reg::i128(),
-            _ => unreachable!("Align is given as power of 2 no larger than 16 bytes"),
-        };
-        arg.cast_to(Uniform { unit, total: Size::from_bytes(2 * align_bytes) });
-    }
-}
-
-pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {
-    if !fn_abi.ret.is_ignore() {
-        classify_ret(&mut fn_abi.ret);
-    }
+use crate::abi::call::FnAbi;
+use crate::abi::{HasDataLayout, TyAbiInterface};
 
-    for arg in fn_abi.args.iter_mut() {
-        if arg.is_ignore() {
-            continue;
-        }
-        classify_arg(arg);
-    }
-}
+pub fn compute_abi_info<Ty>(_fn_abi: &mut FnAbi<'_, Ty>) {}
 
-pub fn compute_ptx_kernel_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)
+pub fn compute_ptx_kernel_abi_info<'a, Ty, C>(_cx: &C, fn_abi: &mut FnAbi<'a, Ty>)
 where
     Ty: TyAbiInterface<'a, C> + Copy,
     C: HasDataLayout,
@@ -54,11 +14,4 @@ pub fn compute_ptx_kernel_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>
     if !fn_abi.ret.layout.is_unit() && !fn_abi.ret.layout.is_never() {
         panic!("Kernels should not return anything other than () or !");
     }
-
-    for arg in fn_abi.args.iter_mut() {
-        if arg.is_ignore() {
-            continue;
-        }
-        classify_arg_kernel(cx, arg);
-    }
 }
diff --git a/compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs b/compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs
index b0582b235b9..007753fb5a7 100644
--- a/compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs
+++ b/compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs
@@ -11,8 +11,8 @@ pub fn target() -> Target {
             os: "cuda".into(),
             vendor: "nvidia".into(),
             linker_flavor: LinkerFlavor::Ptx,
-            // The linker can be installed from `crates.io`.
-            linker: Some("rust-ptx-linker".into()),
+            linker: None,
+            requires_lto: true,
 
             // With `ptx-linker` approach, it can be later overridden via link flags.
             cpu: "sm_30".into(),
@@ -28,7 +28,7 @@ pub fn target() -> Target {
 
             // Avoid using dylib because it contain metadata not supported
             // by LLVM NVPTX backend.
-            only_cdylib: true,
+            // only_cdylib: true,
 
             // Let the `ptx-linker` to handle LLVM lowering into MC / assembly.
             obj_is_bitcode: true,
diff --git a/tests/assembly/asm/nvptx-types.rs b/tests/assembly/asm/nvptx-types.rs
index c319946b5f5..6282ee7ba88 100644
--- a/tests/assembly/asm/nvptx-types.rs
+++ b/tests/assembly/asm/nvptx-types.rs
@@ -1,9 +1,10 @@
 // assembly-output: emit-asm
+// no-prefer-dynamic
 // compile-flags: --target nvptx64-nvidia-cuda
-// compile-flags: --crate-type cdylib
 // needs-llvm-components: nvptx
 
-#![feature(no_core, lang_items, rustc_attrs, asm_experimental_arch)]
+#![feature(no_core, lang_items, rustc_attrs, asm_sym, asm_experimental_arch)]
+#![crate_type = "cdylib"]
 #![no_core]
 
 #[rustc_builtin_macro]
@@ -30,9 +31,10 @@ impl Copy for i64 {}
 impl Copy for f64 {}
 impl Copy for ptr {}
 
-// NVPTX does not support static variables
-#[no_mangle]
-fn extern_func() {}
+extern "C" {
+    fn extern_func();
+    static extern_static: u32;
+}
 
 // CHECK-LABEL: .visible .func sym_fn()
 // CHECK: // begin inline asm
-- 
2.40.1


From 31c89828122353fbbab9a334b4267dacc8dab119 Mon Sep 17 00:00:00 2001
From: Julia Tatz <tatz.j@northeastern.edu>
Date: Tue, 25 Apr 2023 11:15:22 -0400
Subject: [PATCH 7/7] Fix broken cast

---
 compiler/rustc_codegen_llvm/src/consts.rs       | 2 +-
 compiler/rustc_codegen_ssa/src/codegen_attrs.rs | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/compiler/rustc_codegen_llvm/src/consts.rs b/compiler/rustc_codegen_llvm/src/consts.rs
index 5ec22a1c8d7..ec7e73570e9 100644
--- a/compiler/rustc_codegen_llvm/src/consts.rs
+++ b/compiler/rustc_codegen_llvm/src/consts.rs
@@ -414,7 +414,7 @@ fn codegen_static(&self, def_id: DefId, is_mutable: bool) {
                     name.len(),
                     val_llty,
                     attrs.address_space.is_some(),
-                    attrs.address_space.unwrap_or_default() as c_uint,
+                    attrs.address_space.unwrap_or_default() as _,
                 );
 
                 llvm::LLVMRustSetLinkage(new_g, linkage);
diff --git a/compiler/rustc_codegen_ssa/src/codegen_attrs.rs b/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
index 2eeb74fb36f..460f963482a 100644
--- a/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
+++ b/compiler/rustc_codegen_ssa/src/codegen_attrs.rs
@@ -678,7 +678,7 @@ fn check_address_space(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {
             let msg =
                 format!("address space value in `address_space` is too large: `{}`", &ordinal);
             tcx.sess
-                .struct_span_err(attr.span, &msg)
+                .struct_span_err(attr.span, msg)
                 .note("the value may not exceed `u16::MAX`")
                 .emit();
             None
-- 
2.40.1

